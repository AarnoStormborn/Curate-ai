"""Email service for sending research briefs."""

import hashlib
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from pathlib import Path

import aiosmtplib
from jinja2 import Environment, FileSystemLoader, select_autoescape

from curate_ai.agents.schemas import EmailBrief
from curate_ai.config import get_settings
from curate_ai.logging import get_logger

logger = get_logger(__name__)

# Default template if file not found
DEFAULT_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
               line-height: 1.6; color: #333; max-width: 680px; margin: 0 auto; padding: 20px; }
        h1 { color: #1a1a1a; font-size: 24px; border-bottom: 2px solid #007AFF; padding-bottom: 10px; }
        h2 { color: #333; font-size: 18px; margin-top: 30px; }
        .angle { background: #f8f9fa; border-left: 4px solid #007AFF; padding: 15px; margin: 20px 0; }
        .insight { font-size: 16px; font-weight: 600; color: #1a1a1a; margin-bottom: 10px; }
        .why { color: #555; margin-bottom: 15px; }
        .audience { font-size: 12px; color: #888; margin-bottom: 10px; }
        .framing { margin: 10px 0; padding-left: 20px; }
        .framing li { margin: 5px 0; color: #444; }
        .links { margin-top: 15px; }
        .links a { color: #007AFF; text-decoration: none; font-size: 13px; }
        .confidence { font-size: 11px; color: #888; margin-top: 10px; }
        .stats { background: #f0f0f0; padding: 10px; margin-top: 30px; font-size: 12px; color: #666; }
        .footer { margin-top: 30px; font-size: 12px; color: #888; border-top: 1px solid #ddd; padding-top: 15px; }
    </style>
</head>
<body>
    <h1>üî¨ Curate AI Research Brief</h1>
    <p style="color: #666; font-size: 14px;">Generated: {{ brief.generated_at.strftime('%B %d, %Y at %H:%M UTC') }}</p>
    
    {% for angle in brief.angles %}
    <div class="angle">
        <div class="insight">{{ angle.insight }}</div>
        <div class="why">{{ angle.why_it_matters }}</div>
        <div class="audience">üìç Relevant for: {{ angle.relevant_for | join(', ') }}</div>
        
        <h3 style="font-size: 14px; margin: 15px 0 10px 0;">Framing Ideas:</h3>
        <ul class="framing">
        {% for point in angle.framing_points %}
            <li>{{ point }}</li>
        {% endfor %}
        </ul>
        
        {% if angle.supporting_links %}
        <div class="links">
            üîó <strong>Sources:</strong>
            {% for link in angle.supporting_links %}
            <a href="{{ link }}">{{ link | truncate(50) }}</a>{% if not loop.last %}, {% endif %}
            {% endfor %}
        </div>
        {% endif %}
        
        <div class="confidence">Confidence: {{ (angle.confidence * 100) | int }}%</div>
    </div>
    {% endfor %}
    
    <div class="stats">
        <strong>Run Statistics:</strong> 
        {{ brief.topics_considered }} topics considered ‚Üí 
        {{ brief.topics_filtered }} passed filter ‚Üí 
        {{ brief.angles_generated }} angles generated ‚Üí 
        {{ brief.angles | length }} selected
    </div>
    
    <div class="footer">
        <p>This brief was generated by Curate AI. Human remains in the loop - no auto-publishing.</p>
        <p>Run ID: {{ brief.run_id }}</p>
    </div>
</body>
</html>
"""

PLAIN_TEXT_TEMPLATE = """
CURATE AI RESEARCH BRIEF
Generated: {{ brief.generated_at.strftime('%B %d, %Y at %H:%M UTC') }}
========================================

{% for angle in brief.angles %}
---
## Angle {{ loop.index }}

{{ angle.insight }}

WHY IT MATTERS:
{{ angle.why_it_matters }}

RELEVANT FOR: {{ angle.relevant_for | join(', ') }}

FRAMING IDEAS:
{% for point in angle.framing_points %}
‚Ä¢ {{ point }}
{% endfor %}

{% if angle.supporting_links %}
SOURCES:
{% for link in angle.supporting_links %}
- {{ link }}
{% endfor %}
{% endif %}

Confidence: {{ (angle.confidence * 100) | int }}%

{% endfor %}
========================================
Run Statistics: {{ brief.topics_considered }} topics ‚Üí {{ brief.topics_filtered }} filtered ‚Üí {{ brief.angles | length }} selected
Run ID: {{ brief.run_id }}

---
Curate AI - Human in the loop, always.
"""


class EmailService:
    """Service for sending email briefs via SMTP."""

    def __init__(self):
        self.settings = get_settings()
        self._setup_templates()

    def _setup_templates(self):
        """Set up Jinja2 templates."""
        templates_dir = Path(__file__).parent.parent / "templates"

        if templates_dir.exists():
            self.env = Environment(
                loader=FileSystemLoader(templates_dir),
                autoescape=select_autoescape(["html", "xml"]),
            )
        else:
            # Use default templates from strings
            self.env = Environment(autoescape=select_autoescape(["html", "xml"]))

    def render_html(self, brief: EmailBrief) -> str:
        """Render email brief as HTML."""
        try:
            template = self.env.get_template("email_template.html")
            return template.render(brief=brief)
        except Exception:
            # Fall back to default template
            from jinja2 import Template
            template = Template(DEFAULT_TEMPLATE)
            return template.render(brief=brief)

    def render_plain(self, brief: EmailBrief) -> str:
        """Render email brief as plain text."""
        from jinja2 import Template
        template = Template(PLAIN_TEXT_TEMPLATE)
        return template.render(brief=brief)

    def compute_content_hash(self, content: str) -> str:
        """Compute hash of email content for deduplication."""
        return hashlib.sha256(content.encode()).hexdigest()[:16]

    async def send(
        self,
        brief: EmailBrief,
        recipient: str | None = None,
    ) -> tuple[bool, str | None]:
        """
        Send the email brief.
        
        Args:
            brief: The email brief to send
            recipient: Override recipient (defaults to config)
        
        Returns:
            Tuple of (success, error_message)
        """
        settings = self.settings
        to_addr = recipient or settings.email_to

        if not to_addr:
            return False, "No recipient configured"

        if not settings.smtp_host or not settings.smtp_user:
            return False, "SMTP not configured"

        try:
            # Render content
            html_content = self.render_html(brief)
            text_content = self.render_plain(brief)

            # Create message
            msg = MIMEMultipart("alternative")
            msg["Subject"] = f"üî¨ AI Research Brief - {datetime.now().strftime('%b %d')}"
            msg["From"] = settings.email_from or settings.smtp_user
            msg["To"] = to_addr

            # Attach both versions
            msg.attach(MIMEText(text_content, "plain"))
            msg.attach(MIMEText(html_content, "html"))

            # Send via SMTP
            await aiosmtplib.send(
                msg,
                hostname=settings.smtp_host,
                port=settings.smtp_port,
                username=settings.smtp_user,
                password=settings.smtp_password,
                start_tls=True,
            )

            logger.info(
                "Email sent successfully",
                recipient=to_addr,
                run_id=brief.run_id,
                angles=len(brief.angles),
            )

            return True, None

        except Exception as e:
            error_msg = str(e)
            logger.error(
                "Failed to send email",
                error=error_msg,
                recipient=to_addr,
            )
            return False, error_msg


async def send_brief(brief: EmailBrief, recipient: str | None = None) -> bool:
    """
    Convenience function to send an email brief.
    
    Args:
        brief: The EmailBrief to send
        recipient: Optional override recipient
    
    Returns:
        True if sent successfully
    """
    service = EmailService()
    success, error = await service.send(brief, recipient)

    if not success:
        logger.error("Email send failed", error=error)

    return success
